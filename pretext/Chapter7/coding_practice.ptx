<?xml version="1.0"?>
<section xml:id="chapter7_coding-practice">
  <title>Coding Practice</title>
  <listing xml:id="empty-271">
    <statement/>
    <program interactive="" language="" xml:id="empty-272"/>
    <solution>
                Below is one way to implement the program. We use the isalpha function
                    to ignore the non alphabetical characters. Then we continuously check to see
                    if the letters in the front are equal to the ones in the back until we reach the
                    middle of the string.

    <program xml:id="cp_7_AC_1a" language="cpp" line-numbers="yes"><input><![CDATA[
#include <iostream>
#include <cctype>
using namespace std;

bool isPalindrome (string input) {
    int front = 0;
    int back = input.length() - 1;
    while (front < back) {
        while (!isalpha(input[front])) {
            front++;
        }
        while (!isalpha(input[back])) {
            back--;
        }
        if (input[front] != input[back]) {
            return false;
        }
        front++;
        back--;
    }
    return true;
}
        ]]></input><tests>
#define CATCH_CONFIG_MAIN
#include &lt;catch.hpp&gt;

TEST_CASE("factorial function") {
    REQUIRE(isPalindrome ("racecar") == 1);
    REQUIRE(isPalindrome ("no lemon, no melon") == 1);
    REQUIRE(isPalindrome ("kangaroo") == 0);
}
</tests></program>
            
                <p>Below is one way to implement the program. We use the <c>isalpha</c> function
                    to ignore the non alphabetical characters. Then we continuously check to see
                    if the letters in the front are equal to the ones in the back until we reach the
                    middle of the string.</p>

    
            </solution>
  </listing>
  <raw format="html" xml:space="preserve">
&lt;div class="runestone sqcontainer %(optclass)s"&gt;
&lt;div data-component="selectquestion" id=cp_7_AC_2q_sq data-questionlist='cp_7_AC_2q, cp_7_AC_2q_pp'         data-toggleoptions="toggle, lock" data-togglelabels="togglelabels:" data-limit-basecourse=true&gt;
    &lt;p&gt;Loading a dynamic question ...&lt;br/&gt;Selecting from: cp_7_AC_2q, cp_7_AC_2q_pp&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</raw>
  <listing xml:id="empty-273">
    <statement/>
    <program interactive="" language="" xml:id="empty-274"/>
    <solution>
                Below is one way to implement the program. We use a while loop to
                    repeatedly search for instances of word in input. Once found, we replace
                    the length of the word with asterisks.

    <program xml:id="cp_7_AC_3a" language="cpp" line-numbers="yes"><input><![CDATA[
#include <iostream>
using namespace std;

void censorWord(string input, string word) {
    int length = word.length();
    while ((int)input.find(word) != -1) {
        int index = input.find(word);
        int i = 0;
        while (i < length) {
            input[index + i] = '*';
            i++;
        }
    }
    cout << input;
}

int main() {
    censorWord ("I really, really, really, really, really, really like you", "really");
}
        ]]></input></program>
            
                <p>Below is one way to implement the program. We use a while loop to
                    repeatedly search for instances of word in input. Once found, we replace
                    the length of the word with asterisks.</p>

    
            </solution>
  </listing>
  <raw format="html" xml:space="preserve">
&lt;div class="runestone sqcontainer %(optclass)s"&gt;
&lt;div data-component="selectquestion" id=cp_7_AC_4q_sq data-questionlist='cp_7_AC_4q, cp_7_AC_4q_pp'         data-toggleoptions="toggle, lock" data-togglelabels="togglelabels:" data-limit-basecourse=true&gt;
    &lt;p&gt;Loading a dynamic question ...&lt;br/&gt;Selecting from: cp_7_AC_4q, cp_7_AC_4q_pp&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</raw>
  <listing xml:id="empty-275">
    <statement/>
    <program interactive="" language="" xml:id="empty-276"/>
    <solution>
                Below is one way to implement the ROT13 function. We use a while loop to
                    go through all the letters in the string. If the letter is between &#x2018;a' and &#x2018;n' or
                    &#x2018;A' and &#x2018;N', we use character operations to add 13 to each letter. Otherwise,
                    we subtract 13 from each letter. We return the encrypted message at the end.

    <program xml:id="cp_7_AC_5a" language="cpp" line-numbers="yes"><input><![CDATA[
#include <iostream>
#include <cctype>
using namespace std;

string ROT13(string input) {
    int n = 0;
    while (n < (int)input.length()) {
        if (isalpha(input[n])) {
            if ((input[n] >= 'a' && input[n] < 'n') || (input[n] >= 'A' && input[n] < 'N')) {
                input[n] = input[n] + 13;
            }
            else {
                input[n] = input[n] - 13;
            }
        }
        n++;
    }
    return input;
}

int main() {
    string original = "Encrypt me then decrypt me!";
    string encrypted = ROT13 (original);
    string decrypted = ROT13 (encrypted);
    cout << "Original string: " << original << endl;
    cout << "Encrypted string: " << encrypted << endl;
    cout << "Decrypted string: " << decrypted << endl;

    // Uncomment and run the code below once your function works!
    // string secretMessage = "Pbatenghyngvbaf! Lbh'ir fhpprffshyyl vzcyrzragrq EBG13 naq qrpbqrq gur frperg zrffntr :)";
    // cout << ROT13 (secretMessage) << endl;
}
        ]]></input></program>
            
                <p>Below is one way to implement the <c>ROT13</c> function. We use a <c>while</c> loop to
                    go through all the letters in the <c>string</c>. If the letter is between &#x2018;a' and &#x2018;n' or
                    &#x2018;A' and &#x2018;N', we use character operations to add 13 to each letter. Otherwise,
                    we subtract 13 from each letter. We return the encrypted message at the end.</p>

    
            </solution>
  </listing>
  <raw format="html" xml:space="preserve">
&lt;div class="runestone sqcontainer %(optclass)s"&gt;
&lt;div data-component="selectquestion" id=cp_7_AC_6q_sq data-questionlist='cp_7_AC_6q, cp_7_AC_6q_pp'         data-toggleoptions="toggle, lock" data-togglelabels="togglelabels:" data-limit-basecourse=true&gt;
    &lt;p&gt;Loading a dynamic question ...&lt;br/&gt;Selecting from: cp_7_AC_6q, cp_7_AC_6q_pp&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</raw>
  <listing xml:id="empty-277">
    <statement/>
    <program interactive="" language="" xml:id="empty-278"/>
    <solution>
                Below is one way to implement the capitalize function. We use a while loop to
                    go through all the chars in the string. We capitalize the first character
                    and all characters following a space using toupper. At the end, we return the string.

    <program xml:id="cp_7_AC_7a" language="cpp" line-numbers="yes"><input><![CDATA[
#include <iostream>
#include <cctype>
using namespace std;

string capitalize (string input) {
    int n = 0;
    while (n < (int)input.length()) {
        if (n == 0) {
            input[n] = toupper(input[n]);
        }
        else if (input[n-1] == ' ') {
            input[n] = toupper(input[n]);
        }
        n++;
    }
    return input;
}

int main() {
    cout << capitalize ("every word in this string should be capitalized!") << endl;
    cout << capitalize ("this String As well") << endl;
}
        ]]></input></program>
            
                <p>Below is one way to implement the <c>capitalize</c> function. We use a <c>while</c> loop to
                    go through all the <c>char</c>s in the <c>string</c>. We capitalize the first character
                    and all characters following a space using <c>toupper</c>. At the end, we return the <c>string</c>.</p>

    
            </solution>
  </listing>
  <raw format="html" xml:space="preserve">
&lt;div class="runestone sqcontainer %(optclass)s"&gt;
&lt;div data-component="selectquestion" id=cp_7_AC_8q_sq data-questionlist='cp_7_AC_8q, cp_7_AC_8q_pp'         data-toggleoptions="toggle, lock" data-togglelabels="togglelabels:" data-limit-basecourse=true&gt;
    &lt;p&gt;Loading a dynamic question ...&lt;br/&gt;Selecting from: cp_7_AC_8q, cp_7_AC_8q_pp&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</raw>
  <listing xml:id="empty-279">
    <statement/>
    <program interactive="" language="" xml:id="empty-280"/>
    <solution>
                Below is one way to implement the longestWord function. We use a while loop to
                    go through all the chars in the string. We use variables to keep track of the
                    longest word, the longest amount of letters, and the length of the current word. We
                    can determine the length of a word by counting the number of chars between spaces.
                    If the length is greater than the max, length becomes the new max and we update the longest word.
                    This keeps repeating until we reach the end of the string, and the longest word is returned.

    <program xml:id="cp_7_AC_9a" language="cpp" line-numbers="yes"><input><![CDATA[
#include <iostream>
using namespace std;

string longestWord (string input) {
    int n = 0;
    string longest;
    int maxLength = 0;
    while (n < (int)input.length()) {
        int wordLength = 0;
        while (input[n] != ' ' && n < (int)input.length()) {
            wordLength++;
            n++;
        }
        if (wordLength > maxLength) {
            maxLength = wordLength;
            longest = input.substr(n - maxLength, maxLength);
        }
        n++;
    }
    return longest;
}
        ]]></input><tests>
#define CATCH_CONFIG_MAIN
#include &lt;catch.hpp&gt;

TEST_CASE("longestWord function") {
    REQUIRE(longestWord ("what is the longest word in this string") == "longest");
    REQUIRE(longestWord ("these words are very close in size") == "these");
    REQUIRE(longestWord ("vowels") == "vowels");
}
</tests></program>
            
                <p>Below is one way to implement the <c>longestWord</c> function. We use a <c>while</c> loop to
                    go through all the <c>char</c>s in the <c>string</c>. We use variables to keep track of the
                    longest word, the longest amount of letters, and the length of the current word. We
                    can determine the length of a word by counting the number of <c>char</c>s between spaces.
                    If the length is greater than the max, length becomes the new max and we update the longest word.
                    This keeps repeating until we reach the end of the string, and the longest word is returned.</p>

    
            </solution>
  </listing>
  <raw format="html" xml:space="preserve">
&lt;div class="runestone sqcontainer %(optclass)s"&gt;
&lt;div data-component="selectquestion" id=cp_7_AC_10q_sq data-questionlist='cp_7_AC_10q, cp_7_AC_10q_pp'         data-toggleoptions="toggle, lock" data-togglelabels="togglelabels:" data-limit-basecourse=true&gt;
    &lt;p&gt;Loading a dynamic question ...&lt;br/&gt;Selecting from: cp_7_AC_10q, cp_7_AC_10q_pp&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</raw>
</section>
