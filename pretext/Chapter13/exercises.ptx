<?xml version="1.0"?>
<exercises xml:id="chapter13_multiple-choice-exercises">
  <title>Multiple Choice Exercises</title>
  <exercise label="mce_13_1">
    <statement>
      <p>What is the output of the code below?</p>
      <program line-numbers="yes">
        <code><![CDATA[
enum Month { JAN = 1, FEB, MAR, APR,
MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC };

int main() {
  Month m1 = JUL;
  Month m2 = NOV;
  cout << m1 << " " << m2 << endl;
}
]]></code>
      </program>
    </statement>
    <choices>
      <choice>
        <statement id="mce_13_1_opt_a">
          <p>JULY NOVEMBER</p>
        </statement>
        <feedback>
          What are the actual values of <c>JUL</c> and <c>NOV</c>?
        </feedback>
      </choice>
      <choice>
        <statement id="mce_13_1_opt_b">
          <p>JUL NOV</p>
        </statement>
        <feedback>
          What do the values of enumerated types map to?
        </feedback>
      </choice>
      <choice correct="yes">
        <statement id="mce_13_1_opt_c">
          <p>7 11</p>
        </statement>
        <feedback>
          Since we defined <c>JAN</c> to start at 1, <c>JUL</c> and <c>NOV</c> map to 7 and 11.
        </feedback>
      </choice>
      <choice>
        <statement id="mce_13_1_opt_d">
          <p>6 10</p>
        </statement>
        <feedback>
          Take a closer look at our enumerated type definition.
        </feedback>
      </choice>
    </choices>
  </exercise>
  <exercise label="mce_13_2">
    <statement>
      <p>What is the output of the code below?</p>
      <program line-numbers="yes">
        <code><![CDATA[
int main() {
  string s = "summer";
  switch (s) {
    case "spring":
      cout << "It's spring!";
      break;
    case "summer":
      cout << "It's summer!";
    case "fall":
      cout << "It's fall!";
      break;
    case "winter":
      cout << "It's winter!";
    default:
      cout << "Invalid season!";
      break;
  }
}
]]></code>
      </program>
    </statement>
    <choices>
      <choice>
        <statement id="mce_13_2_opt_a">
          <p>summer</p>
        </statement>
        <feedback>
          Although that is the value of <c>s</c>, is that printed?
        </feedback>
      </choice>
      <choice>
        <statement id="mce_13_2_opt_b">
          <p>It's summer!It's fall!</p>
        </statement>
        <feedback>
          This would be the correct answer if this <c>switch</c> statement worked.
        </feedback>
      </choice>
      <choice>
        <statement id="mce_13_2_opt_c">
          <p>It's summer!It's fall!It's winter!Invalid season!</p>
        </statement>
        <feedback>
          Where are the <c>break</c> statements?
        </feedback>
      </choice>
      <choice correct="yes">
        <statement id="mce_13_2_opt_d">
          <p>Compile error.</p>
        </statement>
        <feedback>
          <c>switch</c> statements can't be used on <c>string</c>s.
        </feedback>
      </choice>
    </choices>
  </exercise>
  <exercise label="mce_13_3">
    <statement>
      <p>What is the output of the code below?</p>
      <program line-numbers="yes">
        <code><![CDATA[
enum Season { SPRING, SUMMER, FALL, WINTER };

int main() {
  Season s = SUMMER;
  switch (s) {
    case SPRING:
      cout << "It's spring!";
      break;
    case SUMMER:
      cout << "It's summer!";
    case FALL:
      cout << "It's fall!";
      break;
    case WINTER:
      cout << "It's winter!";
    default:
      cout << "Invalid season!";
      break;
  }
}
]]></code>
      </program>
    </statement>
    <choices>
      <choice>
        <statement id="mce_13_3_opt_a">
          <p>SUMMER</p>
        </statement>
        <feedback>
          Although that is the value of <c>s</c>, is that printed?
        </feedback>
      </choice>
      <choice correct="yes">
        <statement id="mce_13_3_opt_b">
          <p>It's summer!It's fall!</p>
        </statement>
        <feedback>
          Since there is no <c>break</c> statement after the case for summer but there is one after
            fall, this is correct.
        </feedback>
      </choice>
      <choice>
        <statement id="mce_13_3_opt_c">
          <p>It's summer!It's fall!It's winter!Invalid season!</p>
        </statement>
        <feedback>
          Where are the <c>break</c> statements?
        </feedback>
      </choice>
      <choice>
        <statement id="mce_13_3_opt_d">
          <p>Compile error.</p>
        </statement>
        <feedback>
          Since <c>s</c> is an enumerated type, the <c>Season</c>s are mapped to <c>int</c>s, which are
            valid for <c>switch</c> statements.
        </feedback>
      </choice>
    </choices>
  </exercise>
  <exercise label="mce_13_4">
    <statement>
      <p>Take a look at the <c>struct</c> definition of <c>Entry</c>. If we wanted to make a <c>struct</c> called <c>Dictionary</c>,
        how can we create a <c>vector</c> of <c>Entry</c>s as a member variable?</p>
      <program line-numbers="yes">
        <code>
struct Entry {
  string word;
  int page;
}
</code>
      </program>
    </statement>
    <choices>
      <choice correct="yes">
        <statement id="mce_13_4_opt_a">
          <p>
            <c><![CDATA[vector<Entry> entries;]]></c>
          </p>
        </statement>
        <feedback>
          We create a <c>vector</c> with type <c>Entry</c>.
        </feedback>
      </choice>
      <choice>
        <statement id="mce_13_4_opt_b">
          <p>
            <c>Entry entries</c>
          </p>
        </statement>
        <feedback>
          This only creates one <c>Entry</c>.
        </feedback>
      </choice>
      <choice>
        <statement id="mce_13_4_opt_c">
          <p>
            <c><![CDATA[vector<Dictionary> Entry]]></c>
          </p>
        </statement>
        <feedback>
          This creates a <c>vector</c> of <c>Dictionary</c>s called <c>Entry</c>.
        </feedback>
      </choice>
      <choice>
        <statement id="mce_13_4_opt_d">
          <p>We can't make an object that contains a <c>vector</c>.</p>
        </statement>
        <feedback>
          We can have <c>vector</c>s inside objects.
        </feedback>
      </choice>
    </choices>
  </exercise>
  <exercise label="mce_13_5">
    <statement>
      <p>What is wrong with the code below?</p>
      <program line-numbers="yes">
        <code><![CDATA[
struct Card {
  int suit, rank;

  Card();
  Card(int s, int r);

  void print() const;
  bool isGreater(const Card& c2) const;
  int find(const Deck& deck) const;
};

struct Deck {
  vector<Card> cards;

  Deck();
  Deck(int n);
  void print() const;
  int find(const Card& card) const;
};
]]></code>
      </program>
    </statement>
    <choices>
      <choice>
        <statement id="mce_13_5_opt_a">
          <p>We can't have a <c>vector</c> in <c>Deck</c>.</p>
        </statement>
        <feedback>
          We are allowed to have <c>vector</c>s in objects.
        </feedback>
      </choice>
      <choice correct="yes">
        <statement id="mce_13_5_opt_b">
          <p>The definition of <c>Card::find()</c> is invalid.</p>
        </statement>
        <feedback>
          The definition references <c>Deck</c>, but <c>Deck</c> is defined after <c>Card</c>.
        </feedback>
      </choice>
      <choice>
        <statement id="mce_13_5_opt_c">
          <p>We can't define <c>print()</c> in both <c>Card</c> and in <c>Deck</c>.</p>
        </statement>
        <feedback>
          Although they have the same name, these are two different <c>print()</c> functions.
        </feedback>
      </choice>
      <choice>
        <statement id="mce_13_5_opt_d">
          <p>Nothing is wrong with the code.</p>
        </statement>
        <feedback>
          There is an error in the code. Can you find it?
        </feedback>
      </choice>
    </choices>
  </exercise>
  <exercise label="mce_13_6">
    <statement>
      <p>Why can't we code our <c>shuffle</c> function to work the exact same way humans shuffle cards?</p>
    </statement>
    <choices>
      <choice>
        <statement id="mce_13_6_opt_a">
          <p>Our code can't split the deck exactly in half.</p>
        </statement>
        <feedback>
          We can split the deck exactly in half.
        </feedback>
      </choice>
      <choice>
        <statement id="mce_13_6_opt_b">
          <p>The way our code would shuffle cards would be unpredictable.</p>
        </statement>
        <feedback>
          Part of the problem is that the cards would be shuffled in a predictable manner.
        </feedback>
      </choice>
      <choice>
        <statement id="mce_13_6_opt_c">
          <p>Our code would result in an infinite loop.</p>
        </statement>
        <feedback>
          There's no reason to loop infinitely.
        </feedback>
      </choice>
      <choice correct="yes">
        <statement id="mce_13_6_opt_d">
          <p>Our code would perform a perfect shuffle.</p>
        </statement>
        <feedback>
          Because the cards are shuffled perfectly, the exact ordering of the cards is
            predictable and thus the cards aren't really shuffled.
        </feedback>
      </choice>
    </choices>
  </exercise>
  <exercise label="mce_13_7">
    <statement>
      <p>What is true about helper functions?</p>
    </statement>
    <choices>
      <choice>
        <statement id="mce_13_7_opt_a">
          <p>They are longer than the bigger functions since they do all the work.</p>
        </statement>
        <feedback>
          Most helper functions are shorter than the bigger function.
        </feedback>
      </choice>
      <choice correct="yes">
        <statement id="mce_13_7_opt_b">
          <p>They are simpler functions that help the bigger function.</p>
        </statement>
        <feedback>
          As the name implies, they help a bigger function.
        </feedback>
      </choice>
      <choice correct="yes">
        <statement id="mce_13_7_opt_c">
          <p>They shorten the code used in bigger functions.</p>
        </statement>
        <feedback>
          Usually the bigger function has repetitive code, which is then put into a helper
            function to help shorten the bigger function.
        </feedback>
      </choice>
      <choice correct="yes">
        <statement id="mce_13_7_opt_d">
          <p>They make debugging easier.</p>
        </statement>
        <feedback>
          Since helper functions break down the bigger function into smaller parts, it's easier
            to isolate and identify issues.
        </feedback>
      </choice>
    </choices>
  </exercise>
  <exercise label="mce_13_8">
    <statement>
      <p>Using pseudocode to figure out what helper functions are needed is a characteristic of
        what?</p>
    </statement>
    <choices>
      <choice>
        <statement id="mce_13_8_opt_a">
          <p>Encapsulation</p>
        </statement>
        <feedback>
          This is the process of wrapping up a sequence of instructions in a function.
        </feedback>
      </choice>
      <choice>
        <statement id="mce_13_8_opt_b">
          <p>Generalization</p>
        </statement>
        <feedback>
          This is the process of taking something specific and making it more general.
        </feedback>
      </choice>
      <choice correct="yes">
        <statement id="mce_13_8_opt_c">
          <p>Top-down design</p>
        </statement>
        <feedback>
          This is the process of using pseudocode to sketch solutions to large problems and
            design the interfaces of helper functions.
        </feedback>
      </choice>
      <choice>
        <statement id="mce_13_8_opt_d">
          <p>Bottom-up design</p>
        </statement>
        <feedback>
          This is the process of writing small, useful functions and then assembling them into
            larger solutions.
        </feedback>
      </choice>
    </choices>
  </exercise>
  <exercise label="mce_13_9">
    <statement>
      <p>Which of the following can lead to off by one errors?</p>
    </statement>
    <choices>
      <choice>
        <statement id="mce_13_9_opt_a">
          <p>Running a for loop too little or too many times.</p>
        </statement>
        <feedback>
          This can lead to too few iterations or too many iterations.
        </feedback>
      </choice>
      <choice>
        <statement id="mce_13_9_opt_b">
          <p>Forgetting that indexing starts at 0.</p>
        </statement>
        <feedback>
          This can lead you to have values that are shifted by one.
        </feedback>
      </choice>
      <choice>
        <statement id="mce_13_9_opt_c">
          <p>Using less than instead of less than or equal to in a while loop.</p>
        </statement>
        <feedback>
          This can lead to running the while loop one less times than what you wanted.
        </feedback>
      </choice>
      <choice correct="yes">
        <statement id="mce_13_9_opt_d">
          <p>All of the above.</p>
        </statement>
        <feedback>
          These can all lead to off by one errors.
        </feedback>
      </choice>
    </choices>
  </exercise>
  <exercise label="mce_13_10">
    <statement>
      <p>What is the amount of time that mergeSort takes?</p>
    </statement>
    <choices>
      <choice correct="yes">
        <statement id="mce_13_10_opt_a">
          <p>n log n</p>
        </statement>
        <feedback>
          This makes mergeSort faster than our previous version of selection sort.
        </feedback>
      </choice>
      <choice>
        <statement id="mce_13_10_opt_b">
          <p>n!</p>
        </statement>
        <feedback>
          mergeSort runs faster than factorial time.
        </feedback>
      </choice>
      <choice>
        <statement id="mce_13_10_opt_c">
          <p>logn</p>
        </statement>
        <feedback>
          mergeSort runs slower than logarithmic time.
        </feedback>
      </choice>
      <choice>
        <statement id="mce_13_10_opt_d">
          <p>n^2</p>
        </statement>
        <feedback>
          This is the time complexity of selection sort.
        </feedback>
      </choice>
    </choices>
  </exercise>
  <exercise label="mce_13_11">
    <statement>
      <p>What kind of sorting algorithm is our <c>sortDeck</c> function? You are encouraged to search up
        these different sorting algorithms!</p>
    </statement>
    <choices>
      <choice>
        <statement id="mce_13_11_opt_a">
          <p>Bubble sort</p>
        </statement>
        <feedback>
          Bubble sort swaps adjacent items and <q>bubbles</q> the lightest items to the top.
        </feedback>
      </choice>
      <choice>
        <statement id="mce_13_11_opt_b">
          <p>Insertion sort</p>
        </statement>
        <feedback>
          Insertion sort selects an item from the unsorted section and puts it in the right
            location in the sorted section.
        </feedback>
      </choice>
      <choice correct="yes">
        <statement id="mce_13_11_opt_c">
          <p>Selection sort</p>
        </statement>
        <feedback>
          Selection sort finds the smallest item at each iteration i and puts it at the ith
            location.
        </feedback>
      </choice>
      <choice>
        <statement id="mce_13_11_opt_d">
          <p>Quicksort</p>
        </statement>
        <feedback>
          Quicksort uses recursive calls to partition a list.
        </feedback>
      </choice>
    </choices>
  </exercise>
</exercises>